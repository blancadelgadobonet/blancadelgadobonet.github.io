<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>reconstruction | Hi, I'm Blanca</title> <meta name="author" content="Blanca Delgado"> <meta name="description" content="reconstructing a scene using two images"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://blancadelgadobonet.github.io/projects/project_p2_reconstruction/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Hi, I'm Blanca</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">reconstruction</h1> <p class="post-description">reconstructing a scene using two images</p> </header> <article> <p><strong>Robots aim to interact with their surroundings</strong>. To do so, information is retrieved from the environment using sensors. One of the cheapest sensors, able to capture a vast quantity of information, is the camera. Yet, the camera reduces the reality to a 2D version. To recover the real scene we can, nevertheless, reconstruct it using additional information, i.e., two images. In this practice, <strong>3D reconstruction</strong> using two images as input will be implemented using Python.</p> <h2 id="software-based-3d-reconstruction">Software-Based 3D Reconstruction</h2> <p>Every 3D point can be seen from two rays; one ray comes from the first image and a second ray comes from the second image. These rays emerge from the center of each camera, go through a point in the 2D image (where the 3D point is projected) and reach a 3D point in the scene. They can be visualized as two lasers meeting at a unique 3D point. This concept is the basis of 3D reconstruction. <strong>Given the two 2D points</strong> (in the images) in which a single 3D point is projected, <strong>we can triangulate to approximate the position of the 3D point</strong> in the scene. Hence, given two images we can approximate the 3D scene.</p> <p>Now, finding all correspondences in the 2D images is costly. It takes time and matching errors can be produced. To optimize the process, different strategies have been adopted. On the first hand, a sparse or a dense approach can be posed. On the other hand, geometric - epipolar - properties can be considered.</p> <p>A dense approach consideres all points in the 2D images, whereas a sparse approach selects the most characteristic points (e.g., edges) in the images to build the 3D scene. The former allows a more complete, but much slower, reconstruction. The latter tends to be less complete, but might retain all essential information if points are well chosen. Because less points are considered, it results much faster. <strong>Attentive restriction</strong> consists on focusing on certain pixels in the images, instead of reconstructing all of them.</p> <p>Epipolar geometry is the geometry derived from stereo vision, when two cameras (or one moving camera) view the 3D scene from two distinct positions. The <strong>epipolar restriction</strong> defines, for each point in the first image, a line (or a margin, to consider possible erros) in the second image in which its correspondence should be found. Furthermore, a <strong>maximum disparity</strong> can be established within the line: this is the maximum distance in the horizontal axis between the point in one image and the point in the other image. Hence, the correspondence can be reduced to a line in the horizontal axis (epipolar line) and a line in the vertical axis (with a width according to the horizontal axis).</p> <p>Using these restrictions, the matches can be identified much more efficiently and used for triangulation to calculate the 3D positions. The final result looks as follows:</p> <div class="embed-container"> <iframe width="640" height="390" src="https://www.youtube.com/embed/xRQ7DFDMx-A" frameborder="0" allowfullscreen=""></iframe> </div> <style>.embed-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;margin-bottom:5%;margin-top:5%}.embed-container iframe,.embed-container object,.embed-container embed{position:absolute;top:0;left:0;width:100%;height:100%}</style> <p>First, <strong>feature points</strong> are detected in both images (attentive constraint). Points from one image are then matched to their corresponding points in the second image applying the <strong>epipolar constraint</strong> (the point in the first image needs to be in the epipolar line of the second image) and the <strong>maximum disparity</strong> (only points in the second image, within the epipolar line, close to the point in the first image are accepted). Then, correspondences are used to <strong>triangulate</strong> so as to obtain the 3D point. Finally, the best approximations are plotted to reconstruct the scene.</p> <h3 id="okey-but-how">Okey, but how?</h3> <p>To reconstruct the scene, stereo vision is crucial. Two images, looking at the same scene, need to be acquired. They are also smoothed using bilateral filtering (<code class="language-plaintext highlighter-rouge">cv2.bilateralFilter</code>), to remove noise.</p> <p>To apply the <u>attentive restriction</u>, characteristic points from the image are chosen: edges. The edges are selected using the Canny filter (<code class="language-plaintext highlighter-rouge">cv2.Canny</code>) and using the colored image as input. Automatic thresholds were successfully chosen according to the following formulae:</p> <p>\begin{equation} \label{eq:lower} lower = max(0, 0.7 * mean) \end{equation}</p> <p>\begin{equation} \label{eq:upper} upper = min(255, 1.3 * mean) \end{equation}</p> <p><em>Downsampling the image to one cannal - grey values - and smoothing it was also tried as input to the Canny filter, but the performance decreased. Introducing the color image directly to the filter proved better outcomes and was therefore chosen as part of the pipeline.</em></p> <p>Next, the <u>epipolar restriction</u> was applied. To that end, for every point in the first image, the epipolar line in the second image - joining the epipole of the second camera and the point of the first camera projected in the second camera - is computed.</p> <p>Projecting the <strong>center</strong> of the first camera (in homogeneous coordinates) in the second camera, the <strong>epipole</strong> of the second image is obtained:</p> <p>\begin{equation} \label{eq:epipole} e_2 = P_1 * C_2 \end{equation}</p> <p>This point, in optical coordinates, is then transformed to graphic coordinates (<code class="language-plaintext highlighter-rouge">HAL.opticalToGrafic</code>).</p> <p>To <strong>project the point of the first camera in the second camera</strong>, the point needs to be written in homogeneous coordinates and transformed from graphical to optical coordinates (<code class="language-plaintext highlighter-rouge">HAL.graficToOptical</code>). It is then backprojected to the 3D scene (<code class="language-plaintext highlighter-rouge">HAL.backproject</code>) and projected again but to the second camera (<code class="language-plaintext highlighter-rouge">HAL.project</code>). Lastly, it is transformed back from optical to graphic coordenates (<code class="language-plaintext highlighter-rouge">HAL.opticalToGrafic</code>).</p> <p>Using the episode and the point of interest (both in the same camera), the <strong>epipolar line</strong> in homogeneous coordinates (i.e., l1x+l2y+l3z=0) is computed through a cross product. To get the segment of the line lying in the image, the crossing points with the left and right borders of the image is calculated. The left point should be (x0, ?, 1) and the right point (x1, ?, 1), both in homogeneous coordinates, such that</p> <p>\begin{equation} \label{eq:left} y_l = - (l1 x0 + l3 )/ l2 \end{equation}</p> <p>\begin{equation} \label{eq:right} y_r = - (l1 x1 + l3) / l2 \end{equation}</p> <p>Given the segment, it is plotted on a mask with a determined margin, i.e., 10 pixels of thickness (<code class="language-plaintext highlighter-rouge">cv2.line</code>).</p> <p>Up to now, for each point in the first image, all points in the second image corresponding to edges and lying in the line should be considered. But an additional requirement is introduced: <u>maximum disparity</u>. Only points (in the second image) that are close to the original index (in the first image) - that is, within a maximum disparity - are going to be analysed. In this project, a maximum disparity of 20 pixels was allowed.</p> <p><em>In addition, another restriction was tried. Points in the second image that had already found a match in the first image were excluded for posterior matches under the hypothesis that correspondences were 1:1. Ideally, the analysis would have speed up the processing and more accurate matches would have been obtained. Yet, the performance was worsen. Indeed, correspondes are not necessarily 1:1 so this restriction was removed from the reconstruction.</em></p> <p>Next, points in the second image (and their neighbourhood), corresponding to edges, lying within the line, and with a predefined maximum disparity are compared to the point in the first image (and its neighbourhood). To compare the possibilities, both kernels (each point and its neighbourhood, i.e., 11x11) are transformed to HSV and the mean squared error is computed. The match with the smallest error is chosen.</p> <p>Having chosen two points, one on each image, they are back-projected to the 3D scene. Using the centers of both cameras and the two 3D points, <u>triangulation</u> is performed. Two rays are formed and the (approximated) intersection between both gives the 3D position of the matching 2D points.</p> <p>One ray is formed joining the center of one camera with the reference point in said camera; another ray is formed joining the center of a second camera with the corresponding point in the second camera. Finally, the crossing point between both rays - the desired 3D point - is approximated through least squares error.</p> <p>The parametric equation of the first ray, <em>R = (r1, r2, r2)’</em>, is:</p> <p>\begin{equation} \label{eq:ray1} R_1 = P_1 + s V_1 \end{equation}</p> <p>where <em>P1 = (p1, p2, p3)’</em> is the point in the reference image and V1 is the vector director joining the center of the first camera with point in said camera (i.e., <em>V1 = CP1 = P1 - C = (p1, p2, p3)’ - (c1, c2, c3)’</em>).</p> <p>Equivalently, the parametric equation of the second ray is:</p> <p>\begin{equation} \label{eq:ray2} R_2 = P_2 + t V_2 \end{equation}</p> <p>Hence, the interesction between the two rays is given by:</p> <p>\begin{equation} \label{eq:interesection} (x, y, z)’ = P_1 + s V_1 = P_2 + t V_2 \end{equation}</p> <p>that is,</p> <p>\begin{equation} \label{eq:mse-intersection} [V_1, -V_2] (s, t)’ - (P_2 - P_1) = 0 \end{equation}</p> <p>Yet, the rays do not necessarily cross, and the equation is not necessarily solvable. Hence, a least squares error problem can be posed, such that,</p> <p>\begin{equation} \label{eq:mse} Ax - b = 0 \end{equation}</p> <p>where <em>A = [V1, -V2] (3-by-2)</em>, <em>x = (s, t)’</em> (2-by-1, and <em>b = P2 - P1</em> (3-by-1).</p> <p>After computing <em>s</em> and <em>t</em> we can obtain the intersection using either equation of the lines. Yet, because the approximation is not necessarily exact, solutions might differ. The mean between the solutions is therefore returned, and the distance between both solutions (i.e., both points) is given as an error metric. Finally, triangulations with an error below a threshold (of 30), are projected to the 3D scene (<code class="language-plaintext highlighter-rouge">HAL.project3DScene</code>) and plotted (<code class="language-plaintext highlighter-rouge">GUI.ShowNewPoints</code>), using the color from the first image.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Blanca Delgado. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: June 27, 2023. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>